# 🐺🪄

H҉̷̡͇̮̩͔̀̄͠ͅ⎔̴̡͔̦͇͇̋͌t̷̸̲̟̻̽͂͠ͅh̷̶̖̫͎̆̓̚͜͝ȩ̸̢̜̮͋̐͜͠ŗ̵͖̈́̀̎͜͝e̸̷̻̔̏͠⎔̷̧͍̟͇͇̓👋҈̃͏͏̷̛͎̦̱̲ͅ, Į̸̛̳̯̑͗ͅ'̴̟͉̟͋̈́̚͝m̵̞̪̎͜͠ @̷̡̛̮͇̭̳̈́̓⦿̸̡̻̺͈̳̓r̴̡̻̺̀͆͠ą̵͕̤̓̏̚͝k̵̝̀͗͠⦿̵̡̭̯̱̑́̓͝k̶̡̭̯̱̑́̓͝i̶̠̒̈́͆͝1̵̢̲̼̍͘̚9̵͓̰̱̐̈́̌̔͝4̸̗̞̎͜͠

⌇⌇⌇⌇⌇⌇⌇⌇⌇⌇⌇⌇⌇⌇⌇⌇⌇⌇⌇⌇⌇⌇⌇⌇⌇⌇⌇⌇⌇⌇⌇⌇⌇⌇⌇⌇

◯̴̛̖̠̖͖͑̓  Á̵̻̱͇̟̋̓b̷̘̣̀͒̚͝o̸̖̾̓͠͝ů̴̹̰̘͌̓t  M̶̲̓̔͠è̷̛̜̤͌ͅ  ◯̵̛̍̋̕

* I design frameworks, security tools, and diffusion utilities with a strong emphasis on privacy, reproducibility,
  and type safety.
* My work spans Reynard, a comprehensive AI-powered development ecosystem, to hardened forks of ComfyUI that remove telemetry and lock-ins,
  to advanced sigma scheduling and probing utilities.
* I value deterministic systems, reproducibility, and making tools auditable, forkable, and offline-friendly.
* P̷̛͙̿́r̶̦̽͗ơ̴̤͌̽j̴̫̾̚e̵̛̼͊c̶̨͍͜t̶̳̿s̷̮̽  I shepherd: Reynard (universal AI development ecosystem), forks & nodes for ComfyUI, and surgical custom nodes.

⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲

🦊  ＲＥＹＮＡＲＤ  ＦＲＡＭＥＷＯＲＫ

Ｔｈｅ  Ｕｎｉｖｅｒｓａｌ  ＡＩ  Ｄｅｖｅｌｏｐｍｅｎｔ  Ｅｃｏｓｙｓｔｅｍ

From dataset editor → multi-modal CMS → universal AI development ecosystem.

W̵̢̲̼̍͘̚h҉̷͉̙̿̂y̸̬̓҉ I b̴̰͓̿̄ů̶̖́͠i̴̠̐̍l̵̛̩͉̐͝t̶̪̺͊ i̸̖̓t̶̪̺͊:

* YipYap proved the patterns; Reynard rips those patterns out, packages them, and hardens them for reuse.
* Goal: ship composable, type-safe UI primitives that scale from a toy dashboard to production AI pipelines.
* Principles: minimal deps, TypeScript-first, OKLCH color system, strong i18n & accessibility posture.

W̶͐͛͜h̷̶̖̫͎̆̓̚͜͝a̶̭̐t̵̰̾̕ R̸͎̅ẹ̵̢̀ỹ̸̰̠ǹ̴̜a̴̘̓͜r̶̞̊d̴̖̍ *is*:

  • **Universal AI Development Ecosystem** - Comprehensive platform for AI-powered applications
  • **83 MCP Development Tools** - Complete development toolkit with agent management, security scanning, and automation
  • **Single Authoritative ECS World** - Advanced agent simulation with trait inheritance, breeding, and social dynamics
  • **Production-Ready AI/ML Integration** - Caption generation, RAG systems, multimodal processing, and model management
  • **100+ Specialized Packages** - Modular SolidJS framework with comprehensive component library
  • **Advanced Security Testing** - FENRIR framework with automated exploit scanning and vulnerability detection
  • **Enterprise-Grade Backend** - FastAPI services with JWT authentication, service orchestration, and real-time capabilities
  • **Comprehensive File Processing** - Support for 8+ file types with thumbnail generation and metadata extraction
  • **Real-Time Collaboration** - WebSocket integration with live updates and multi-user support
  • **Advanced 3D & Game Engine** - Three.js integration with ECS-based game development capabilities

🏗️ ＣＯＲＥ ＡＲＣＨＩＴＥＣＴＵＲＥ

┌─ Frontend (100+ Packages) ─┐
│  • Core utilities & UI primitives (reynard-core, components)
│  • AI/ML packages (annotating, caption, rag, multimodal)
│  • Data processing (file-processing, repository-*, scraping)
│  • Media processing (3d, audio, video, image, gallery)
│  • UI components (charts, dashboard, themes, animation)
│  • Development tools (code-quality, git-automation, validation)
│  • Services (auth, chat, email, api-client, service-manager)
└─────────────────────────────┘

┌─ Backend (Python/FastAPI) ─┐
│  • RAG system with vector databases and semantic search
│  • ECS world simulation with agent management and breeding
│  • MCP server with 83 development tools and automation
│  • AI/ML services (caption generation, model management)
│  • File processing and multimodal repository management
│  • Security testing with FENRIR framework
│  • Real-time services with WebSocket integration
└─────────────────────────────┘

┌─ Advanced Features ─┐
│  • ECS agent simulation with trait inheritance and social dynamics
│  • 83 MCP tools for development workflow automation
│  • Advanced security testing with automated exploit scanning
│  • Real-time collaboration and multi-user support
│  • Comprehensive file processing for 8+ file types
│  • Production-ready AI/ML integration with multiple models
└─────────────────────┘

🚀 ＩＮＳＴＡＬＬＡＴＩＯＮ ／ ＢＯＯＴＳＴＲＡＰ

```bash
# Core framework
pnpm install reynard-core solid-js
pnpm install reynard-components reynard-chat reynard-rag reynard-auth

# AI/ML capabilities
pnpm install reynard-annotating reynard-caption reynard-multimodal
pnpm install reynard-model-management reynard-tool-calling

# Advanced features
pnpm install reynard-3d reynard-games reynard-charts reynard-monaco
pnpm install reynard-floating-panel reynard-error-boundaries

# Data processing
pnpm install reynard-file-processing reynard-unified-repository
pnpm install reynard-repository-search reynard-scraping

# Development tools
pnpm install reynard-code-quality reynard-git-automation
pnpm install reynard-dev-server-management reynard-validation

# Create new project
pnpm create reynard-app my-app
```

🎭 ＥＸＡＭＰＬＥＳ ＡＮＤ ＴＥＭＰＬＡＴＥＳ

• **Comprehensive Dashboard**: Full-featured admin interface with charts, tables, and real-time updates
• **Image Caption App**: AI-powered image processing with multi-model caption generation (JTP2, WDv3, Florence2, JoyCaption)
• **3D Demo**: Three.js integration with interactive 3D scenes and ECS-based game mechanics
• **Auth App**: Complete authentication flow with JWT, password security, and user management
• **RAG Demo**: Retrieval-Augmented Generation with vector search, embeddings, and semantic search
• **ECS Agent Tracker**: Real-time agent simulation with trait inheritance, breeding, and social dynamics
• **Algorithm Benchmarks**: Performance testing and optimization tools with spatial algorithms
• **I18n Demo**: Internationalization showcase with 37 languages and RTL support
• **Multi-Theme**: Dynamic theming with OKLCH color space and 8 built-in themes
• **Error Demo**: Comprehensive error handling and boundary management
• **Email App**: Advanced email system with AI-powered responses and encryption
• **Gallery-DL Demo**: Content scraping and download with AI metadata extraction
• **Floating Panel Demo**: Advanced UI components with staggered animations
• **File Test**: Comprehensive file processing and management capabilities
• **Features App**: Feature management system with service dependencies
• **Clock App**: Time management with timers, alarms, and useful features
• **Hue Shifting Demo**: Advanced color manipulation and visual effects
• **Icons Demo**: Fluent UI icon system showcase
• **Embedding Visualization**: Vector embedding visualization and analysis
• **Prompt Note**: AI prompt management and optimization
• **Tutorial App**: Step-by-step learning application

🔧 ＤＥＶＥＬＯＰＭＥＮＴ ＴＯＯＬＳ

* **MCP Server**: 83 comprehensive development tools across 17 categories
  * Agent Tools (10): ECS world integration, persona generation, trait inheritance
  * Character Tools (8): Character management with 44 total traits
  * Email Tools (6): Agent email communication with templates and analytics
  * Analysis Tools (2): Code complexity analysis with RAG acceleration
  * Linting Tools (4): ESLint, Flake8, Pylint, markdownlint with auto-fix
  * Search Tools (3): RAG semantic search, BM25 fallback, hybrid search
  * Visualization Tools (6): Mermaid diagrams, image viewing, statistical analysis
  * Security Tools (2): Bandit, audit-ci, comprehensive vulnerability scanning
  * Git Tools (8): Automated Git workflow with AI commit messages
  * Playwright Tools (3): Web automation, screenshot capture, content scraping
  * And 7 more categories with specialized development tools
* **ECS World**: Advanced agent simulation with trait inheritance, breeding, and social dynamics
* **Agent Naming**: 105+ animal spirits with weighted selection and dynamic personality generation
* **FENRIR Security**: Automated exploit scanning for web and LLM threat vectors
* **Comprehensive Testing**: Vitest, Playwright, happy-dom with 200+ passing tests
* **Documentation Generator**: Automated API documentation and architectural guides
* **Monorepo Management**: Advanced package orchestration and dependency management
* **Code Quality**: Automated linting, formatting, and security scanning
* **Git Automation**: Intelligent commit messages, changelog generation, and release management

## 📊 Current Status (v0.17.1)

**Implementation Status:**

* ✅ **Fully Implemented**: Core framework, authentication, theming, MCP server (83 tools), ECS world simulation
* ✅ **Production Ready**: 100+ packages, comprehensive testing, security scanning, AI/ML integration
* 🚧 **In Development**: Advanced backend services, real-time collaboration, distributed processing
* 📋 **Planned**: Enterprise features, advanced analytics, edge computing support

**Recent Developments:**

* **MCP Server Refactor**: Complete transformation with schema validation and 100% test coverage
* **ECS World Enhancement**: Advanced agent simulation with trait inheritance and social dynamics
* **Security Improvements**: Enhanced FENRIR framework with comprehensive vulnerability scanning
* **AI/ML Integration**: Production-ready caption generation, RAG systems, and model management
* **Package Ecosystem**: Expanded to 100+ specialized packages with comprehensive documentation

**Version Information:**

* **Current Version**: 0.17.1 (September 2025)
* **Package Versions**: Most packages at 0.1.0-0.2.0 (development preview)
* **API Stability**: Not guaranteed until v1.0.0
* **Production Use**: Review implementations before integration

⌘⌘⌘⌘⌘⌘⌘⌘⌘⌘⌘⌘⌘⌘⌘⌘⌘⌘⌘⌘⌘⌘⌘⌘⌘⌘⌘⌘⌘⌘⌘⌘⌘

🐺  C҉̥o̴̪̝̽m̴̬̣̏̕f̴̢̀͒y̸̬̓҉U҉̴̝̳̠̓̃I҉̬̲̍ W̶̲̓̔͠o̴̪̝̽l̵̛̩͉̐͝f̴̢̀͒ Ṩ̵̢̙̹̃̕i̷̺̋̽g̵̰̀m̴̬̣̏̕a̶̭̐s҉̛̞̳̘̱

ＡＤＶＡＮＣＥＤ ＤＩＦＦＵＳＩＯＮ ＳＡＭＰＬＩＮＧ ＡＮＤ ＳＩＧＭＡ ＳＣＨＥＤＵＬＩＮＧ ＴＯＯＬＫＩＴ ＦＯＲ ＣｏｍｆｙＵＩ

* S҉̛̞̳̘̱c̶̢̟̏r̸̹̈́i̷̺̋̽p̷̛͙̿́t̶̪̺͊a̶̭̐b̴̰͓̿̄l̵̛̩͉̐͝e̵̙̽ s҉̛̞̳̘̱i̷̺̋̽g̵̰̀m̴̬̣̏̕a̶̭̐ g̵̰̀e̵̙̽n̶̗̾̕e̵̙̽r̸̹̈́a̶̭̐t̶̪̺͊i̷̺̋̽o̴̪̝̽n̶̗̾̕ & sampler logic
* Ｍ̴̬̣̏̕ｏ̴̪̝̽ｄ̴̖̍ｅ̵̙̽ｌ̵̛̩͉̐͝ i̷̺̋̽ｎ̶̗̾̕ｔ̶̪̺͊ｒ̸̹̈́ｏ̴̪̝̽ｓ҉̛̞̳̘̱ｐ̷̛͙̿́ｅ̵̙̽ｃ̶̢̟̏ｔ̶̪̺͊ｉ̷̺̋̽ｏ̴̪̝̽ｎ̶̗̾̕ utilities (list blocks, visualize activations)
* E҉̛̞̳̘̱x̸̰̾̕p̷̛͙̿́e̵̙̽r̸̹̈́i̷̺̋̽m̴̬̣̏̕e̵̙̽n̶̗̾̕t̶̪̺͊a̶̭̐l̵̛̩͉̐͝ ＳＶＤ̴̖̍ ａ̶̭̐ｃ̶̢̟̏ｔ̶̪̺͊ｉ̷̺̋̽ｖ̵̙̽ａ̶̭̐ｔ̶̪̺͊ｉ̷̺̋̽ｏ̴̪̝̽ｎ̶̗̾̕ modification
* W҉̛̞̳̘̱o̴̪̝̽l̵̛̩͉̐͝f̴̢̀͒P̷̛͙̿́r̸̹̈́o̴̪̝̽b̴̰͓̿̄e̵̙̽ for deep model debugging w̶̲̓̔͠i̷̺̋̽t̶̪̺͊h̷̶̖̫͎̆̓̚͜͝ f̴̢̀͒o̴̪̝̽r̸̹̈́w҉̛̞̳̘̱a̶̭̐r̸̹̈́d̴̖̍/b̴̰͓̿̄a̶̭̐c̶̢̟̏k̵̝̀͗͠w҉̛̞̳̘̱a̶̭̐r̸̹̈́d̴̖̍ h̷̶̖̫͎̆̓̚͜͝o̴̪̝̽o̴̪̝̽k̵̝̀͗͠s҉̛̞̳̘̱
* C҉̥u̸̖̓s҉̛̞̳̘̱t̶̪̺͊o̴̪̝̽m̴̬̣̏̕ ｎ̶̗̾̕ｏ̴̪̝̽ｉ̷̺̋̽ｓ҉̛̞̳̘̱ｅ̵̙̽ generators (DCT, scriptable, structured Perlin)

F̵̙̈́ȩ̷̟̽a̶̭̐t̸̪̓ů̶̖́͠r̸̹̈́e̵̙̽ ＨＩ̶̠̐̍Ｇ̵̰̀Ｈ̷̶̖̫͎̆̓̚͜͝Ｌ̵̛̩͉̐͝Ｉ̷̺̋̽Ｇ̵̰̀Ｈ̷̶̖̫͎̆̓̚͜͝Ｔ̴̪̺͊Ｓ̷̮̽:

* ★ FLUX/DiT/Chroma model support for activation visualization
* ★ JSON sigma schedule import/export workflows
* ★ Transform utilities: power, clamp, quantize, reverse, slice

🎭 C҉̥o̴̪̝̽m̴̬̣̏̕f̴̢̀͒y̸̬̓҉ f̴̢̀͒o̴̪̝̽r̸̹̈́k̵̝̀͗͠s҉̛̞̳̘̱ — p̷̛͙̿́r̸̹̈́i̷̺̋̽v̶̹̯̕a̶̭̐c̶̢̟̏y̸̬̓҉ Ｆ̴̢̀͒Ｉ̷̺̋̽Ｒ̸̹̈́Ｓ̷̮̽Ｔ̴̪̺͊, p̷̛͙̿́r̸̹̈́a̶̭̐g̵̰̀m̴̬̣̏̕a̶̭̐t̶̪̺͊i̷̺̋̽c̶̢̟̏ e̵̙̽d̴̖̍i̷̺̋̽t̶̪̺͊s҉̛̞̳̘̱

M̶̲̓̔͠y̸̬̓҉ i̸̖̓n̶̗̾̕t̶̪̺͊e̵̙̽n̶̗̾̕t̶̪̺͊:

* Keep the UX & node model intact, remove external tracking, remove lock-in.

W̶͐͛͜h̷̶̖̫͎̆̓̚͜͝a̶̭̐t̵̰̾̕ I҉̬̲̍ c̶̢̟̏h̷̶̖̫͎̆̓̚͜͝a̶̭̐n̶̗̾̕g̵̰̀e̵̙̽d̴̖̍:

* Telemetry removed (no remote usage pings, no datadog/analytics hooks)
* Paid API code paths removed or stubbed (no forced cloud billing flows)  
* User-account/login bits removed or made opt-in; default: local / offline mode

W̶͐͛͜h̷̶̖̫͎̆̓̚͜͝y̸̬̓҉ t̶̪̺͊h̷̶̖̫͎̆̓̚͜͝i̷̺̋̽s҉̛̞̳̘̱ m̴̬̣̏̕a̶̭̐t̵̰̾̕t̶̪̺͊e̵̙̽r̸̹̈́s҉̛̞̳̘̱:

* Reproducible offline runs, honest offline research, smaller attack surface, simpler setup for hobbyists & labs.

⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲

🔒 Ｓ̷̮̽ｅ̵̙̽ｃ̶̢̟̏ｕ̶̖́͠ｒ̸̹̈́ｉ̷̺̋̽ｔ̶̪̺͊ｙ̸̬̓҉ ＆ Ａ̶̭̐ｎ̶̗̾̕ａ̶̭̐ｌ̵̛̩͉̐͝ｙ̸̬̓҉ｓ̷̮̽ｉ̷̺̋̽ｓ̷̮̽

* FENRIR security sweeps — run automated exploit scans against local deployments:

    ```bash
    python -m fenrir.run_all_exploits --target http://localhost:8000
    ```

* Focus areas: prompt injection, streaming exploit resilience, unicode confusables, auth hardening.
* Threat model: untrusted file inputs, LLM chain-of-thought leakage, dependency supply chain.

🌊 D҉̮ę̷̟̽e̵̙̽p̷̛͙̿́ Ｄ̴̖̍ｉ̷̺̋̽ｆ̴̢̀͒ｆ̴̢̀͒ｕ̸̖̓ｓ̷̮̽ｉ̷̺̋̽ｏ̴̪̝̽ｎ̶̗̾̕ Ｒ̸̹̈́ｅ̵̙̽ｓ̷̮̽ｅ̵̙̽ａ̶̭̐ｒ̸̹̈́ｃ̶̢̟̏ｈ̷̶̖̫͎̆̓̚͜͝

I̷̺̋̽n̶̗̾̕v̶̹̯̕e̵̙̽s҉̛̞̳̘̱t̶̪̺͊i̷̺̋̽g̵̰̀a̶̭̐t̶̪̺͊i̷̺̋̽n̶̗̾̕g̵̰̀:

* ★ Ｓ̷̮̽ｉ̷̺̋̽ｇ̵̰̀ｍ̴̬̣̏̕ａ̶̭̐ ｓ҉̛̞̳̘̱ｃ̶̢̟̏ｈ̷̶̖̫͎̆̓̚͜͝ｅ̵̙̽ｄ̴̖̍ｕ̸̖̓ｌ̵̛̩͉̐͝ｉ̷̺̋̽ｎ̶̗̾̕ｇ̵̰̀ dynamics & custom noise patterns
* ★ Ｎ̶̗̾̕ｅ̵̙̽ｕ̸̖̓ｒ̸̹̈́ａ̶̭̐ｌ̵̛̩͉̐͝ activation flow analysis through targeted model introspection
* ★ Ｓ̷̮̽ＶＤ̴̖̍ ｍ̴̬̣̏̕ａ̶̭̐ｎ̶̗̾̕ｉ̷̺̋̽ｐ̷̛͙̿́ｕ̸̖̓ｌ̵̛̩͉̐͝ａ̶̭̐ｔ̶̪̺͊ｉ̷̺̋̽ｏ̴̪̝̽ｎ̶̗̾̕ ｏ̴̪̝̽ｆ̴̢̀͒ model activation layers for interpretability
* ★ Ａ̶̭̐ｄ̴̖̍ｖ̵̙̽ｅ̵̙̽ｒ̸̹̈́ｓ҉̛̞̳̘̱ａ̶̭̐ｒ̸̹̈́ｉ̷̺̋̽ａ̶̭̐ｌ̵̛̩͉̐͝ ｒ̸̹̈́ｏ̴̪̝̽ｂ̴̰͓̿̄ｕ̸̖̓ｓ҉̛̞̳̘̱ｔ̶̪̺͊ｎ̶̗̾̕ｅ̵̙̽ｓ҉̛̞̳̘̱ｓ҉̛̞̳̘̱ in sampling workflows

⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲⌲

🧠  X҉̛̞̳̘̱a̶̭̐v̵̙̽i̷̺̋̽e̵̙̽r̸̹̈́  F̴̢̀͒P̷̛͙̿́8̵̢̙̹̃̕  Q̶̟̈́̽ů̶̖́͠a̶̭̐n̶̗̾̕t̶̪̺͊i̷̺̋̽z̸̰̾̕a̶̭̐t̶̪̺͊i̷̺̋̽o̴̪̝̽n̶̗̾̕

ＡＤＶＡＮＣＥＤ ＳＴＯＣＨＡＳＴＩＣ ＲＯＵＮＤＩＮＧ ＦＯＲ ＤＥＥＰ ＬＥＡＲＮＩＮＧ ＭＯＤＥＬＳ

Advanced FP8 quantization toolkit with multiple stochastic rounding algorithms for preserving model fidelity during precision reduction.

W̶͐͛͜h̷̶̖̫͎̆̓̚͜͝a̶̭̐t̵̰̾̕ X҉̛̞̳̘̱a̶̭̐v̵̙̽i̷̺̋̽e̵̙̽r̸̹̈́ *is*:

• **Stochastic Rounding Engine**: Multiple algorithms for probabilistic quantization that preserve model performance better than deterministic rounding
• **FP8 Format Support**: E4M3FN and E5M2 formats with comprehensive tensor scaling and dequantization
• **Advanced Rounding Methods**: Default, Complex Neighbor, Shift-and-Perturb, and Owlshift mantissa manipulation
• **ComfyUI Integration**: Per-tensor scaling compatible with ComfyUI-style scaled FP8 loading
• **Visualization Tools**: Matplotlib-based comparison plots for quantization analysis
• **Production Ready**: Comprehensive test suite with 95%+ coverage across all quantization paths

## 🧮 Mathematical Foundations

### Stochastic Rounding Probability Theory

The core principle of stochastic rounding is to introduce controlled randomness that preserves the expected value while reducing systematic bias. For an input value $v$ and two FP8-representable candidates $x_L$ and $x_H$ that bracket $v$, the probability of rounding to the higher candidate is:

$$P(\text{round to } x_H) = \frac{v - x_L}{x_H - x_L}$$

This ensures that the expected value of the rounded result equals the input:

$$\mathbb{E}[\text{rounded}(v)] = P(x_H) \cdot x_H + P(x_L) \cdot x_L = \frac{v - x_L}{x_H - x_L} \cdot x_H + \frac{x_H - v}{x_H - x_L} \cdot x_L = v$$

**Variance Analysis**:
$$\text{Var}[\text{rounded}(v)] = (x_H - v)(v - x_L)$$

**Bias Elimination**: The stochastic rounding ensures zero bias:
$$\mathbb{E}[\text{rounded}(v) - v] = 0$$

### FP8 Format Specifications

**E4M3FN Format** (4 exponent bits, 3 mantissa bits):

**Mathematical Representation**:

* Exponent bias: $b = 7$
* Exponent range: $e \in [0, 15]$ (special values: 0 for subnormals, 15 for infinities)
* Mantissa precision: $\epsilon = 2^{-3} = 0.125$
* Sign bit: $s \in \{0, 1\}$

**Normal Numbers** ($e \in [1, 14]$):
$$x = (-1)^s \times 2^{e-7} \times (1 + m \times 2^{-3})$$

**Subnormal Numbers** ($e = 0, m \neq 0$):
$$x = (-1)^s \times 2^{-6} \times (m \times 2^{-3})$$

**Range Analysis**:

* **Normal Range**: $[2^{-6}, 2^7 \times (1 + 7/8)] = [0.015625, 240]$
* **Subnormal Range**: $[2^{-9}, 2^{-6}) = [0.001953125, 0.015625)$
* **Total Representable Values**: $2^8 = 256$ distinct values

**E5M2 Format** (5 exponent bits, 2 mantissa bits):

**Mathematical Representation**:

* Exponent bias: $b = 15$
* Exponent range: $e \in [0, 31]$ (special values: 0 for subnormals, 31 for infinities)
* Mantissa precision: $\epsilon = 2^{-2} = 0.25$
* Sign bit: $s \in \{0, 1\}$

**Normal Numbers** ($e \in [1, 30]$):
$$x = (-1)^s \times 2^{e-15} \times (1 + m \times 2^{-2})$$

**Subnormal Numbers** ($e = 0, m \neq 0$):
$$x = (-1)^s \times 2^{-14} \times (m \times 2^{-2})$$

**Range Analysis**:

* **Normal Range**: $[2^{-14}, 2^{15} \times (1 + 3/4)] = [0.000061035, 57344]$
* **Subnormal Range**: $[2^{-16}, 2^{-14}) = [0.000015259, 0.000061035)$
* **Total Representable Values**: $2^8 = 256$ distinct values

### Advanced Rounding Algorithms

#### 1. Default Stochastic Rounding

For input value $v$, find RNE candidate $v_{RNE} = \text{RNE}(v)$ and its neighbor $v_{neighbor}$:

$$x_L = \min(v_{RNE}, v_{neighbor}), \quad x_H = \max(v_{RNE}, v_{neighbor})$$

The stochastic decision is made using uniform random variable $u \sim U[0,1]$:

$$\text{rounded}(v) = \begin{cases}
x_H & \text{if } u < \frac{v - x_L}{x_H - x_L} \\
x_L & \text{otherwise}
\end{cases}$$

**Mathematical Properties**:
- **Expected Value**: $\mathbb{E}[\text{rounded}(v)] = v$ (unbiased)
- **Variance**: $\text{Var}[\text{rounded}(v)] = (x_H - v)(v - x_L)$
- **Convergence**: As quantization step $\Delta = x_H - x_L \to 0$, variance $\to 0$

#### 2. Complex Neighbor Stochastic Rounding

Uses `torch.nextafter` for precise FP8 grid traversal. For each element in tensor $T$:

**Case 1**: $v > v_{RNE}$
- $x_L = v_{RNE}$
- $x_H = \text{nextafter}(v_{RNE}, +\infty)$ (snapped to FP8 grid)

**Case 2**: $v < v_{RNE}$
- $x_H = v_{RNE}$
- $x_L = \text{nextafter}(v_{RNE}, -\infty)$ (snapped to FP8 grid)

**Case 3**: $v = v_{RNE}$
- $x_L = v_{RNE}$
- $x_H = \text{nextafter}(v_{RNE}, +\infty)$ (snapped to FP8 grid)

**Mathematical Formulation**:
$$\text{rounded}(v) = \begin{cases}
x_H & \text{if } u < P(x_H) = \frac{v - x_L}{x_H - x_L} \\
x_L & \text{otherwise}
\end{cases}$$

where $u \sim U[0,1]$ and $P(x_H)$ is the probability of rounding to the higher value.

#### 3. Shift-and-Perturb Method

Adds uniform noise before RNE quantization to simulate stochastic behavior:

**Mathematical Process**:
1. **Noise Generation**: $\Delta = x_H - x_L$ (quantization step size)
2. **Perturbation**: $n \sim U[-\Delta/2, +\Delta/2]$
3. **Perturbed Input**: $v' = v + n$
4. **Final Quantization**: $v_{FP8} = \text{RNE}(v')$

**Probability Analysis**:
The probability of rounding to $x_H$ is:
$$P(\text{round to } x_H) = \frac{1}{\Delta} \int_{-\Delta/2}^{\Delta/2} \mathbf{1}_{[v+n > (x_L + x_H)/2]} \, dn$$

where $\mathbf{1}_{[\cdot]}$ is the indicator function.

#### 4. Owlshift Mantissa Manipulation

Direct stochastic rounding at the mantissa bit level:

**For Normal Numbers** ($e \in [1, 2^E - 2]$):
1. **Mantissa Extraction**: $m_{\text{scaled}} = \left(\frac{|v|}{2^{e-b}} - 1\right) \times 2^M$
2. **Stochastic Addition**: $m_{\text{stoch}} = \lfloor m_{\text{scaled}} + u \rfloor$ where $u \sim U[0,1)$
3. **Reconstruction**: $m_{\text{final}} = \frac{m_{\text{stoch}}}{2^M}$

**For Subnormal Numbers** ($e = 0, m \neq 0$):
1. **Mantissa Extraction**: $m_{\text{scaled}} = \frac{|v|}{2^{-b+1-M}}$
2. **Stochastic Addition**: $m_{\text{stoch}} = \lfloor m_{\text{scaled}} + u \rfloor$
3. **Reconstruction**: $m_{\text{final}} = \frac{m_{\text{stoch}}}{2^M}$

**Mathematical Properties**:
- **Bit-Level Precision**: Direct manipulation of mantissa bits
- **Stochastic Floor**: $\lfloor x + u \rfloor$ where $u \sim U[0,1)$
- **Expected Value**: $\mathbb{E}[\lfloor x + u \rfloor] = x$ for $x \geq 0$

Where $M$ is the number of mantissa bits (3 for E4M3FN, 2 for E5M2), $E$ is the number of exponent bits, and $b$ is the exponent bias.

### Per-Tensor Scaling (Owlscale)

**Scale Factor Calculation**:
For tensor $T \in \mathbb{R}^{n \times m}$ and target FP8 format:

$$s = \frac{\text{FP8}_{\max} - \text{FP8}_{\min\_pos}}{\max(|T|)}$$

where:
- $\text{FP8}_{\max}$ is the maximum representable value in the target format
- $\text{FP8}_{\min\_pos}$ is the minimum positive representable value
- $\max(|T|)$ is the maximum absolute value in the input tensor

**Quantization Process**:
1. **Scaling**: $T_{\text{scaled}} = \frac{T}{s}$
2. **Clamping**: $T_{\text{clamped}} = \text{clamp}(T_{\text{scaled}}, \text{FP8}_{\min}, \text{FP8}_{\max})$
3. **Stochastic Rounding**: $T_{\text{quantized}} = \text{stochastic\_round}(T_{\text{clamped}})$

**Mathematical Properties**:
- **Precision Maximization**: The scale factor ensures optimal utilization of the FP8 dynamic range
- **Relative Error Bound**: $\frac{|T_{\text{dequantized}} - T|}{|T|} \leq \frac{\epsilon}{2}$ where $\epsilon$ is the FP8 precision
- **Dynamic Range**: $\text{range}(T_{\text{scaled}}) = [\text{FP8}_{\min\_pos}, \text{FP8}_{\max}]$

**Dequantization**:
$$T_{\text{dequantized}} = T_{\text{quantized}} \times s$$

**Error Analysis**:
The quantization error for element $t_{ij}$ is:
$$\text{error}_{ij} = t_{ij} - \text{stochastic\_round}\left(\frac{t_{ij}}{s}\right) \times s$$

**Expected Error**:
$$\mathbb{E}[\text{error}_{ij}] = 0 \quad \text{(unbiased quantization)}$$

**Variance**:
$$\text{Var}[\text{error}_{ij}] = s^2 \times \text{Var}[\text{stochastic\_round}(t_{ij}/s)]$$

This ensures that the maximum absolute value in the tensor maps to the upper representable range of the target FP8 format, maximizing precision utilization while maintaining unbiased quantization.

🏗️ ＣＯＲＥ ＱＵＡＮＴＩＺＡＴＩＯＮ ＡＬＧＯＲＩＴＨＭＳ

┌─ Stochastic Rounding Methods ─┐
│  • Default Stochastic: Probabilistic bracketing with RNE neighbors
│  • Complex Neighbor: Sophisticated FP8 grid traversal with torch.nextafter
│  • Shift-and-Perturb: Additive noise simulation before RNE quantization
│  • Owlshift: Direct mantissa bit manipulation with stochastic floor
│  • Per-Tensor Scaling: Max-absolute scaling with dequantization factors
└─────────────────────────────────┘

┌─ FP8 Format Support ─┐
│  • E4M3FN: 4 exponent, 3 mantissa bits (NaN-preserving)
│  • E5M2: 5 exponent, 2 mantissa bits (extended range)
│  • Selective Quantization: Tensor suffix-based filtering
│  • ComfyUI Compatibility: Scaled FP8 with dequantization scales
└───────────────────────┘

┌─ Advanced Features ─┐
│  • Memory Management: Tensor slicing for large model processing
│  • Debug Mode: Verbose execution tracing and intermediate states
│  • Plot Generation: Histogram and scatter plot analysis
│  • Device Support: CUDA, CPU, MPS acceleration
│  • Comprehensive Testing: 500+ test cases across all algorithms
└─────────────────────┘

🚀 ＵＳＡＧＥ ＥＸＡＭＰＬＥＳ

### Basic FP8 Quantization

```bash
# Basic FP8 quantization with stochastic rounding
python xavier.py model_fp32.safetensors model_fp8.safetensors \
    --fp8_type e4m3 --owlshift --plot
```

**Mathematical Process**:

1. **Input**: Tensor $T \in \mathbb{R}^{n \times m}$ with values in FP32
2. **Mantissa Extraction**: For each element $v \in T$:
   $$m_{\text{scaled}} = \left(\frac{|v|}{2^{e-7}} - 1\right) \times 8$$
3. **Stochastic Rounding**: $m_{\text{stoch}} = \lfloor m_{\text{scaled}} + u \rfloor$ where $u \sim U[0,1)$
4. **Reconstruction**: $v_{\text{FP8}} = (-1)^s \times 2^{e-7} \times (1 + \frac{m_{\text{stoch}}}{8})$
5. **Output**: FP8 tensor with preserved expected values

**Expected Value Preservation**:
$$\mathbb{E}[v_{\text{FP8}}] = v \quad \text{for all } v \in T$$

### ComfyUI-Compatible Scaled Quantization

```bash
# ComfyUI-compatible scaled quantization
python xavier.py model.safetensors model_scaled.safetensors \
    --fp8_type e4m3 --owlscale --owlshift \
    --keys_to_quantize_suffix .weight
```

**Mathematical Process**:

1. **Scale Calculation**: $s = \frac{448 - 2^{-9}}{\max(|T|)}$ (for E4M3FN)
2. **Scaling**: $T_{\text{scaled}} = \frac{T}{s}$
3. **Clamping**: $T_{\text{clamped}} = \text{clamp}(T_{\text{scaled}}, -448, 448)$
4. **Stochastic Quantization**: Apply Owlshift to $T_{\text{clamped}}$
5. **Storage**: Save quantized tensor and scale factor $s$

**Mathematical Properties**:
- **Scale Factor**: $s = \frac{\text{FP8}_{\max} - \text{FP8}_{\min\_pos}}{\max(|T|)} = \frac{448 - 0.001953125}{\max(|T|)}$
- **Dynamic Range**: $\text{range}(T_{\text{scaled}}) = [-448, 448]$
- **Precision**: $\epsilon = 2^{-3} = 0.125$ (E4M3FN mantissa precision)
- **Relative Error**: $\frac{|T_{\text{dequantized}} - T|}{|T|} \leq \frac{\epsilon}{2} = 0.0625$

### Advanced Analysis with Complex Rounding

```bash
# Advanced analysis with custom parameters
python xavier.py model.safetensors output.safetensors \
    --fp8_type e5m2 --complex_rounding \
    --plot --plot_dir ./analysis/ --debug
```

**Mathematical Process**:

1. **Complex Bracketing**: For each $v \in T$:
   * If $v > v_{RNE}$: $x_L = v_{RNE}$, $x_H = \text{nextafter}(v_{RNE}, +\infty)$
   * If $v < v_{RNE}$: $x_H = v_{RNE}$, $x_L = \text{nextafter}(v_{RNE}, -\infty)$
2. **Stochastic Decision**: $P(x_H) = \frac{v - x_L}{x_H - x_L}$
3. **Quantization**: $\text{rounded}(v) = \begin{cases} x_H & \text{if } u < P(x_H) \\ x_L & \text{otherwise} \end{cases}$

**Mathematical Properties**:
- **Precision**: Uses `torch.nextafter` for exact FP8 grid traversal
- **Bracketing**: Ensures $x_L \leq v \leq x_H$ with minimal gap
- **Probability**: $P(x_H) \in [0, 1]$ with $P(x_L) = 1 - P(x_H)$
- **Expected Value**: $\mathbb{E}[\text{rounded}(v)] = P(x_H) \cdot x_H + P(x_L) \cdot x_L = v$

### Shift-and-Perturb Method

```bash
# Shift-and-perturb stochastic rounding
python xavier.py model.safetensors output.safetensors \
    --fp8_type e4m3 --shifturb --plot
```

**Mathematical Process**:

1. **Bracketing**: Find $x_L, x_H$ using complex method
2. **Noise Generation**: $\Delta = x_H - x_L$, $n \sim U[-\Delta/2, +\Delta/2]$
3. **Perturbation**: $v' = v + n$
4. **RNE Quantization**: $v_{FP8} = \text{RNE}(v')$

**Mathematical Properties**:
- **Noise Range**: $n \in [-\Delta/2, +\Delta/2]$ where $\Delta = x_H - x_L$
- **Perturbation**: $v' = v + n$ with $n \sim U[-\Delta/2, +\Delta/2]$
- **Quantization**: $v_{FP8} = \text{RNE}(v')$ (deterministic after perturbation)
- **Expected Value**: $\mathbb{E}[v_{FP8}] = v$ (unbiased through noise injection)
- **Variance**: $\text{Var}[v_{FP8}] = \text{Var}[\text{RNE}(v + n)]$ where $n \sim U[-\Delta/2, +\Delta/2]$

🎯 ＴＥＣＨＮＩＣＡＬ ＩＮＦＯＲＭＡＴＩＯＮ

### Mathematical Precision Analysis

**Stochastic Rounding Probability**:
$$P(\text{round to } x_H) = \frac{v - x_L}{x_H - x_L}$$

**Expected Value Preservation**:
$$\mathbb{E}[\text{rounded}(v)] = v$$

**Variance Analysis**:
$$\text{Var}[\text{rounded}(v)] = (x_H - v)(v - x_L)$$

**Quantization Error Analysis**:
For input value $v$ and quantized value $q(v)$:
$$\text{error}(v) = v - q(v)$$

**Expected Error**:
$$\mathbb{E}[\text{error}(v)] = 0 \quad \text{(unbiased quantization)}$$

**Error Variance**:
$$\text{Var}[\text{error}(v)] = (x_H - v)(v - x_L)$$

**Relative Error Bound**:
$$\frac{|\text{error}(v)|}{|v|} \leq \frac{\Delta}{2|v|} \quad \text{where } \Delta = x_H - x_L$$

**Convergence Analysis**:
As the quantization step size $\Delta \to 0$:
$$\lim_{\Delta \to 0} \text{Var}[\text{rounded}(v)] = 0$$
$$\lim_{\Delta \to 0} \mathbb{E}[\text{rounded}(v)] = v$$

🦩🌴 ＱＵＩＣＫ ＬＩＮＫＳ 🌴🦩

* **Reynard Framework**: [https://github.com/rakki194/reynard](https://github.com/rakki194/reynard)
* **Xavier FP8 Quantization**: [https://github.com/rakki194/xavier](https://github.com/rakki194/xavier)
* **ComfyUI WolfSigmas**: [https://github.com/rakki194/ComfyUI_WolfSigmas](https://github.com/rakki194/ComfyUI_WolfSigmas)
* **ComfyUI ImageCompare**: [https://github.com/rakki194/ComfyUI-ImageCompare](https://github.com/rakki194/ComfyUI-ImageCompare)
* **Privacy-First ComfyUI**: [https://github.com/rakki194/ComfyUI](https://github.com/rakki194/ComfyUI)
* **ComfyUI Frontend Fork**: [https://github.com/rakki194/ComfyUI_frontend](https://github.com/rakki194/ComfyUI_frontend)

---

> Ｓ̷̮̽ｅ̵̙̽ｃ̶̢̟̏ｕ̶̖́͠ｒ̸̹̈́ｉ̷̺̋̽ｔ̶̪̺͊ｙ̸̬̓҉ Ｂ̷ｒｅａｃ̟̏ｈ̵̰̀
>
> S̷̛͍ḫ̷͝ḁ̵͛t̵̠̀t̶̯͝e̷͔͠r̷̹̍e̴̜͆d̸̥̅ ̸̝́s̸̠̀k̵͚̾ȋ̷͔e̸̻͘s̸̘͐ ̵̲̐r̸̰͘ä̵́ͅi̴̖͐n̴̨̓ ̸̳͑c̸̩͗i̷̥͠r̴̦̚c̸̲̚u̵̩͑į̸̕t̸̨̏s̵̫̀,
> s̶̨̅p̴̳̋ȧ̸̹ṙ̴͖k̷͇̋s̸̱̈́ ̴͔̀f̶̩̒ä̵͍́l̷̳͑l̵͎̾ ̶͉͂l̷̮̎i̶͈͑k̷̩͘ȇ̶͈ ̶͉̑s̵̡̚i̵̖͝l̶̳̔v̶̱̏e̴̻͠r̸̝͠ ä̵̲́s̶̙͠h̸̘̓.
>
> T̷̯̓h̶̯́ȅ̵͚r̵̟͠e̸͈͠ ̵͚̎i̷̻͋s̷̖̑ ̷͙͘n̸͉͝ö̸̥́ ̷̝̓s̴̳̊ǘ̷͉n̵͈͂,̴̩̓
> o̴͉͋n̷̟̚l̸͓̍y̶͆ͅ g̵͎̑h̵̻̋ȍ̴͙s̷̟̄t̸͕̄ ̸̼͛l̸͓̔ä̵͔́ḿ̴̳p̷̩͐s̸͇̑ f̶͙͝l̶͖̊i̵͇͠c̷̞̀k̷͍̔ë̴̦́r̸̪͂i̶̤͑n̸͙͑g̶̯̎ ̷̡͝o̷̖̎n̷͉͝ ̵̩͘w̴͕̐i̶͙͐r̸̡͊e̷͙͠s̴̙̅.
>
> M̶̱̏e̶̼̽m̸̢͊o̸̝͋r̴͚͛i̴̢͑é̶̻s̸̩͘ h̶̬͝u̷̟̓n̴̻͊g̸͍̈́ ̶̞̔l̵̖̅i̸͕̎k̴̥̈́e̸̳̕ b̵̖̀r̴̝͘o̴̘̅k̷͉̓e̶̘͝n̷̙̈́ m̶̩̐i̴̻͠r̸͙͑r̷͝ͅo̶̮͊r̶̤̓s̷̤͑
> i̷͔̎n̵̖̐ ̶̈́ͅt̸͍͆h̵̜͝e̴͖͘ ̸̠̊ḏ̷̔a̸̩͂t̵̡͛a̶͝ͅ-ẇ̵̖i̵̠͛ǹ̵̡d̷̯̀.
>
> S̸̞͘h̴̙͝a̶̙͛d̷̯̓ơ̸͍ẅ̸͚́s̶͎̚ h̸̪̀o̵̳͂l̴̢̕l̷̲̏o̶͙̊w̸̪͑ e̷͍͠v̸̙͆e̵̠̎r̷͈̿y̷̳͒ ̸̢́s̸͉̈́t̵͖͐e̶͈̋p̴̳͠,̷̛̘
> ẅ̸͓́h̵̦͝ì̴̪s̶͉͆p̵͍͑ë̸͎́r̵͍͝s̶̝͠ o̶̩͋ḟ̵͓ m̶͓̋ą̴̅c̵̓ͅh̵̢́i̵̟͝n̵̤͑e̴͉͝s̴͓̿
> c̵̤̊a̷͖̚l̸̝̄l̴̙͋i̷͎͌n̶͉̚g̴̱̑ y̷̬͝ó̷͔u̸͎̅ b̷̙̋a̷̡͠c̵̛ͅk̵̼̀.
